<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="我的目标是星辰和大海！"><title>前端模块化入门指南 | Feaswcy</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.2.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/public/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.0.0/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/public/favicon.ico"><link rel="apple-touch-icon" href="/public/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/public/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">前端模块化入门指南</h1><a id="logo" href="/public/.">Feaswcy</a><p class="description">Follow excellence and success will chase you.</p></div><div id="nav-menu"><a href="/public/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/public/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/public/about/"><i class="fa fa-user"> 关于</i></a><a href="/public/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">前端模块化入门指南</h1><div class="post-meta">Apr 23, 2016<span> | </span><span class="category"><a href="/public/categories/web技术/">web技术</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="post-content"><p>最近正在尝试改写一个angular版本的ueditor（戳<a href="http://github.com/charstars/angular-bdeditor" target="_blank" rel="external">angular-bdeditor</a>），代码测试玩人肉处理好加载的example后，发现js的加载顺序实在是一个令人头疼的问题，早些时候了解过一点模块加载方式，比如require.js,sea.js等等，还有各种各样的模块规范CMD,AMD,今天打算详细的梳理一下前端模块化的知识，与前端的小伙伴共勉。</p>
<ol>
<li><p>一切从加载说起<br>大约在09年以前，前端的代码还都是这样的：<br><pre>&lt;script type=”text/javascript” charset=”utf-8” src=”a.js”&gt;&lt;/script&gt;<br>&lt;script type=”text/javascript” charset=”utf-8” src=”b.js”&gt; &lt;/script&gt;</pre><br>其中b.js依赖于a.js，这样载入脚本的方式必须注意到先后的顺序，当项目很小时，这样的人肉管理似乎还能说得过去，但是如果进入到团队的开发协作或者稍微大一点的项目，库的数量增加时，这样的方法会让编写代码者成为名副其实的码农（搬代码的农民），于是聪明的前端工程师开发了一系列的处理工具来处理加载问题，随着时间的推移，工具也越来越多，新旧工具和规范的更迭速度真是让不少外行人惊呼“贵圈真乱！”</p>
</li>
<li><p>命名空间</p>
</li>
</ol>
<p>我想最开始学习JS的同学可能了解到这个名词，命名空间是为了解决在一个js脚本编写的过程中，不同的js文件中用到了相同的文件名造成函数的覆盖，于是参照java的方式，创建一个对象，并且把所有的其他功能都放在这个对象的方法之下，通常是这样：</p>
<p><pre>var app={};</pre></p>
<p>app.afunc=function(){<br>//程序逻辑<br>};<br>app.bfunc=function(){<br>//程序逻辑<br>};<br>著名的jquery库使用的就是这样的方式，这样提供了封装的特性，并且避免的命名造成的冲突问题，通过命名空间，的确减少了冲突的问题，但是等到库的函数变大需求变多时，你可能会看到下面的代码（来自yahoo YUI2项目）：</p>
<p><pre><span class="pl-k">if</span> (<span class="pl-smi">org</span>.<span class="pl-smi">cometd</span>.<span class="pl-smi">Utils</span>.<span class="pl-en">isString</span>(response)) {<br>  <span class="pl-k">return</span> <span class="pl-smi">org</span>.<span class="pl-smi">cometd</span>.<span class="pl-c1">JSON</span>.<span class="pl-en">fromJSON</span>(response);<br>}<br><span class="pl-k">if</span> (<span class="pl-smi">org</span>.<span class="pl-smi">cometd</span>.<span class="pl-smi">Utils</span>.<span class="pl-en">isArray</span>(response)) {<br>  <span class="pl-k">return</span> response;<br>}</pre><br>这样的引用不得不说很有java范，但是每次看到这么长的方法调用，都让人感到自己在做一件有点愚蠢的事，于是著名的YUI团队又开发了一种新的命名空间机制：</p>
<p><pre><span class="pl-c1">YUI</span>().<span class="pl-en">use</span>(<span class="pl-s"><span class="pl-pds">‘</span>node<span class="pl-pds">‘</span></span>, <span class="pl-k">function</span> (<span class="pl-smi">Y</span>) {<br>  <span class="pl-c">// Node 模块已加载好</span><br>  <span class="pl-c">// 下面可以通过 传递进来的参数Y 来调用</span><br>  <span class="pl-k">var</span> foo <span class="pl-k">=</span> <span class="pl-smi">Y</span>.<span class="pl-en">one</span>(<span class="pl-s"><span class="pl-pds">‘</span>#foo<span class="pl-pds">‘</span></span>);<br>});</pre></p>
<p><br>如果你对AMD/CMD规范有所了解的话，这里的编程范式已经和他们有所相似了，只不过这里用来处理命名空间的问题，而AMD/CMD是用来处理文件加载的问题罢了，继以上的命名空间的风格之后，YUI又推出了这样的模块加载写法：</p>
<p><pre><span class="pl-c1">YUI</span>.<span class="pl-c1">add</span>(<span class="pl-s"><span class="pl-pds">‘</span>my-module<span class="pl-pds">‘</span></span>, <span class="pl-k">function</span> (<span class="pl-smi">Y</span>) {<br>  <span class="pl-c">// …</span><br>}, <span class="pl-s"><span class="pl-pds">‘</span>0.0.1<span class="pl-pds">‘</span></span>, {<br>    requires<span class="pl-k">:</span> [<span class="pl-s"><span class="pl-pds">‘</span>node<span class="pl-pds">‘</span></span>, <span class="pl-s"><span class="pl-pds">‘</span>event<span class="pl-pds">‘</span></span>]<br>});</pre><br>上面的代码，通过 <code>requires</code> 等方式来指定当前模块的依赖。这很大程度上可以解决依赖问题，但不够优雅。当模块很多，依赖很复杂时，烦琐的配置会带来不少隐患。</p>
<p>命名冲突和文件依赖，是前端开发过程中的两个经典问题。下来我们继续看看前端对这两个问题的处理。</p>
<ol>
<li>AMD/CMD与commonJS</li>
</ol>
<p>AMD/CMD是加载脚本文件的两种不同方式，以下代码会给你一个直观的认识（代码的原作者为：<a href="https://www.zhihu.com/people/lifesinger" target="_blank" rel="external">知乎-玉伯</a>，侵删）：</p>
<p><pre>// CMD<br>define(function(require, exports, module) {<br>var a = require(‘./a’)<br>a.doSomething()<br>var b = require(‘./b’) // 依赖可以就近书写<br>b.doSomething()<br>// …<br>})</pre></p>
<p>// AMD 默认推荐的是<br>define([‘./a’, ‘./b’], function(a, b) { // 依赖必须一开始就写好<br>a.doSomething()<br>b.doSomething()<br>…<br>}) </p>
<p><br>实际上上面的两种规范都是两个框架在实际开发过程中产出的，如果你打算详细的了解他们可以去<a href="http://seajs.org/do" target="_blank" rel="external">sea.js</a>和<a href="http://requirejs.org/" target="_blank" rel="external">require.js</a>的官方站点了解他们，不得不提的是，还有一个规范叫做，CommonJS Modules/2.0 规范，对应的框架是CommonJS，对于这三者，比较好的记忆方式是：</p>
<ul>
<li>AMD：Asynchronous Module Definition，异步模块定义，主要用于浏览器环境下的加载文件（它也想在node环境被使用），根据AMD的官方文档，使用AMD规范的require.js的具体实现方法是找到html的&lt;/head&gt;标签，并且在此标签前添加上你按照require.js的写法引入的库文件，只要你的文件是按照amd规范的，require.js会自动帮你处理好加载的顺序（当然如果不是amd规范，你可以使用config里的shim方法）。</li>
<li>CMD：Common Module Definition，commonJS基本上是在和AMD做一样的事情，只是他们对规范的定义略有不同，由于commonJS国产并且中文文档比较丰富，你可以自行去官网查看他们的定义和使用方法。</li>
<li>CommonJS  Module：在大多数时候我们只是将它成为，commonJS，与上面两种规范不同的是，commonJs规范并没有一个像sea.js 和require.js那样的库，他是一种在服务器环境下的文件规范，我们知道node.js使javascript在服务器环境下大放异彩，node.js提供一些底层的方法来使频繁的异步I/O操作变得简洁而高效，但是开发者在开发上层工具的过程中，难免会遇到调用其他库的问题，由于javascript语言本身的缺陷，调用需要通过其他方式实现（就像上文的require.js等工具，实际上在其他语言中，如C或GO，使用include和import就可以解决），CommonJS规范解决了这一问题，并且使用commonJS规范的框架逐渐在桌面应用等其他终端上开始使用开来（个人非常期待在嵌入式里能有所应用….）</li>
</ul>
<ol>
<li>ES6的新标准</li>
</ol>
<p>头疼的Javascript发展史还没有结束，但是现在看来ECMAscript 6即将把这些多种多样的规范进行最后的整合：ES6 的module标准，这个标准整合了脚本模块化的各个方案，是未来javascript开发的风向标，他提供了export和import等模块加载的命令，如果你想深入的了解可以去花段时间学习一下ECMAscript6，推荐可以看一下阮一峰的网络日志关于ES6的介绍，网站地址：<a href="http://Common Module Definition" target="_blank" rel="external">ES6-阮一峰</a>，未来的发展趋势一定是向ES6靠拢的，现阶段ES6是否在企业中应用还不太了解，但你可以在这个项目中看到不同浏览器版本对于ES6的支持情况：<a href="https://kangax.github.io/compat-table/es6/" target="_blank" rel="external">ES6 compat-table</a>。</p>
<ol>
<li>一些个人看法</li>
</ol>
<p>在我个人开来，ES6以后一定会逐渐普及的，希望成为前端或者WEB工程师的同学很有必要去学习一下，但是现在如果在公司里做开发的话，应该还是看技术带头人的安排吧，看完本文希望你对JS模块化的发展有一定的认识，并且在找工作时面试时能够派上用途。</p>
</div><script type="text/javascript" src="/public/js/share.js?v=0.0.0" async></script><a data-url="http://notes.feaswcy.com/public/2016/04/23/frontend-module/" data-id="civi5fubx000cn84092yaiqet" class="article-share-link">分享到</a><div class="tags"></div><div class="post-nav"><a href="/public/2016/04/24/yii-freamwork/" class="pre">PHP YII框架搭建</a><a href="/public/2016/04/21/embedded/" class="next">嵌入式开发学习指南</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://notes.feaswcy.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/public/categories/web技术/">web技术</a></li><li class="category-list-item"><a class="category-list-link" href="/public/categories/其他PL/">其他PL</a></li><li class="category-list-item"><a class="category-list-link" href="/public/categories/随笔/">随笔</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/public/tags/前端/" style="font-size: 15px;">前端</a> <a href="/public/tags/工程师，文化，理想/" style="font-size: 15px;">工程师，文化，理想</a> <a href="/public/tags/web技术工程师/" style="font-size: 15px;">web技术工程师</a> <a href="/public/tags/webpack，browserify/" style="font-size: 15px;">webpack，browserify</a> <a href="/public/tags/warmserver/" style="font-size: 15px;">warmserver</a> <a href="/public/tags/yii/" style="font-size: 15px;">yii</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/public/2016/11/16/javascript/">Javascript</a></li><li class="post-list-item"><a class="post-list-link" href="/public/2016/11/14/FE-notes/">前端布局与样式技巧汇总</a></li><li class="post-list-item"><a class="post-list-link" href="/public/2016/11/10/front-end-learning/">The way to FE engineer</a></li><li class="post-list-item"><a class="post-list-link" href="/public/2016/10/27/plc/">关于PLC技术</a></li><li class="post-list-item"><a class="post-list-link" href="/public/2016/10/26/tcp-protocol/">以太网协议解析</a></li><li class="post-list-item"><a class="post-list-link" href="/public/2016/10/25/hello/">Hello hexo</a></li><li class="post-list-item"><a class="post-list-link" href="/public/2016/05/06/vps/">分享一个科学上网的方式</a></li><li class="post-list-item"><a class="post-list-link" href="/public/2016/04/29/webpack-browserify/">使用webpack与browserify</a></li><li class="post-list-item"><a class="post-list-link" href="/public/2016/04/24/yii-freamwork/">PHP YII框架搭建</a></li><li class="post-list-item"><a class="post-list-link" href="/public/2016/04/23/frontend-module/">前端模块化入门指南</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://www.zhihu.com/people/happyfizz" title="知乎" target="_blank">知乎</a><ul></ul><a href="https://github.com/feaswcy" title="Github" target="_blank">Github</a><ul></ul><a href="https://www.haomwei.com/" title="主题开发者" target="_blank">主题开发者</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/public/." rel="nofollow">Feaswcy.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/public/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/public/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/public/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/public/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/public/js/smartresize.js?v=0.0.0"></script></div></body></html>